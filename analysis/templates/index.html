<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Detección de Malware (Random Forest)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Añadido: Para forzar un aspecto cuadrado en el canvas */
        .chart-container-square {
            position: relative;
            width: 500px; /* Ancho fijo para el contenedor */
            height: 500px; /* Alto fijo para el contenedor */
            margin: auto; /* Centrar el gráfico */
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-blue-800 tracking-tight mb-2">
                Análisis de Detección de Malware Android
            </h1>
            <p class="text-lg text-gray-600">Resultados del Modelo de Machine Learning</p>
        </header>

        <div id="status-message" class="text-center py-4 text-xl font-semibold text-gray-700">
            Cargando datos del API de Django...
        </div>

        <main id="dashboard-content" class="space-y-12 hidden">

            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-blue-500">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">1. Métrica F1-Score (Clasificación Binaria)</h2>
                <div class="flex flex-col md:flex-row items-center justify-between">
                    <p class="text-gray-600 text-lg">F1-Score del Clasificador Random Forest (Top 2 Clases):</p>
                    <div class="mt-4 md:mt-0 px-6 py-3 bg-blue-100 text-blue-800 font-extrabold text-4xl rounded-lg shadow-inner" id="accuracy-value">
                        --
                    </div>
                </div>
                <p class="mt-4 text-sm text-gray-500">Este valor mide la precisión y la robustez del modelo en la clasificación de las dos categorías de malware más frecuentes.</p>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-red-500">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">2. Gráfica de Frontera de Decisión (SVM)</h2>
                <img id="grafica1_img" src="" alt="Gráfica de Clasificación SVM" class="mx-auto" style="max-width: 800px; height: auto;">
                <p class="mt-4 text-sm text-gray-500">
                    Frontera de decisión suavizada del clasificador SVM para las 3 clases principales.
                </p>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-teal-500">
                <h2 class="2xl font-bold text-gray-800 mb-4" id="graph-title">3. Gráfica de Superficie de Predicción (Random Forest Regressor)</h2>
                <div class="chart-container-square">
                    <canvas id="regressionSurfaceChart"></canvas> </div>
                <p class="mt-4 text-sm text-gray-500">
                    Superficie de predicción para la variable de regresión (Init_Win_bytes_forward) usando las dos características más importantes.
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-purple-500">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">4. Valores Reales vs. Predicciones (Regresión)</h2>
                <img id="grafica3_img" src="" alt="Gráfica de Reales vs Predichos" class="mx-auto" style="max-width: 800px; height: auto;">
                <p class="mt-4 text-sm text-gray-500">
                    Comparación de los valores reales con los predichos por el modelo de Regresión. Una dispersión cercana a la línea diagonal indica alta precisión.
                </p>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg border-t-4 border-gray-500">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">5. Muestra del Dataset (Primeras 10 filas)</h2>
                <div class="overflow-x-auto rounded-lg border border-gray-200">
                    <table class="min-w-full divide-y divide-gray-200" id="dataframe-table">
                        <thead class="bg-gray-50"></thead>
                        <tbody class="divide-y divide-gray-200 bg-white"></tbody>
                    </table>
                </div>
            </div>

        </main>
    </div>

    <script>
        const API_ENDPOINT = 'api/malware/results/'; 

        // Definimos un mapa de color para la Regresión (usando un esquema de Chart.js)
        const COLOR_MAP_REGRESSION = [
            '#fde047', // Amarillo
            '#fb923c', // Naranja
            '#f43f5e', // Rojo
            '#7c3aed', // Morado
            '#0ea5e9', // Azul
        ];

        /**
         * Función principal para cargar y renderizar los datos del API
         */
        async function loadAndRenderData() {
            const statusMessage = document.getElementById('status-message');
            const dashboardContent = document.getElementById('dashboard-content');
            
            try {
                // 1. Llamar al API de Django
                const response = await fetch(API_ENDPOINT);

                if (!response.ok) {
                    const errorJson = await response.json();
                    // Intentar obtener el mensaje de error del backend
                    const errorMessage = errorJson.message || errorJson.error || 'Error desconocido';
                    throw new Error(`Error HTTP: ${response.status}. Mensaje: Error al ejecutar ML: ${errorMessage}`);
                }

                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.message || data.error);
                }

                // 2. Renderizar el F1-Score
                document.getElementById('accuracy-value').textContent = data.accuracy.toFixed(4);
                
                // 3. Renderizar Gráficas Base64 (Gráfica 1 y Gráfica 3)
                // Gráfica 1 (SVM - Clasificación)
                document.getElementById('grafica1_img').src = `data:image/png;base64,${data.grafica1_b64}`;
                // Gráfica 3 (Reales vs Predichos - Regresión)
                document.getElementById('grafica3_img').src = `data:image/png;base64,${data.grafica3_b64}`;


                // 4. Renderizar la Gráfica 2 (Superficie de Regresión - Chart.js)
                // Usar un bloque try-catch para atrapar el error de JavaScript 78/10 aquí
                try {
                    renderRegressionSurfaceChart(data.regressionData);
                } catch(e) {
                    console.error("Error al renderizar Gráfica de Superficie (Posiblemente error 78/10 en indexación):", e);
                    // Opcional: mostrar un mensaje de error en el contenedor
                    document.getElementById('regressionSurfaceChart').parentElement.innerHTML = '<p class="text-red-500 text-center">Error al renderizar la Gráfica de Superficie. Ver consola.</p>';
                }


                // 5. Renderizar el DataFrame (Tu función original)
                renderDataFrame(data.dataframe);

                // 6. Mostrar el dashboard
                statusMessage.classList.add('hidden');
                dashboardContent.classList.remove('hidden');

            } catch (error) {
                console.error("Error al cargar los datos:", error);
                statusMessage.textContent = `Error: No se pudo conectar con el API o procesar los datos. Ver consola para detalles. Error: ${error.message}`;
                statusMessage.classList.remove('text-gray-700');
                statusMessage.classList.add('text-red-600');
            }
        }

        /**
         * Dibuja la gráfica de Superficie de Predicción de Regresión (Gráfica 2).
         * @param {Object} regressionData - Datos desde el API.
         */
        function renderRegressionSurfaceChart(regressionData) {
            const ctx = document.getElementById('regressionSurfaceChart').getContext('2d');
            
            // --- VERIFICACIÓN CRÍTICA DE SEGURIDAD ---
            if (!regressionData || !regressionData.x_line || !regressionData.x_data || !regressionData.y_data || !regressionData.y_data_class) {
                console.warn("Faltan datos de regresión. No se puede renderizar la superficie.");
                throw new Error("Datos de regresión incompletos.");
            }
            
            // La longitud que esperamos es 10 para los puntos reales (lo que solucionamos en Python)
            const realDataLength = regressionData.x_data.length;

            // 1. Datos para la Superficie (Mapa de Color) - Longitud 2500
            const surfacePoints = regressionData.x_line.map((x, index) => ({
                x: x,
                y: regressionData.y_line[index],
                z: regressionData.z_line[index] // Valor predicho de regresión
            }));
            
            // 2. Datos para los Puntos Reales (Scatter) - Longitud 10
            // ** CORRECCIÓN 78/10 **: Iteramos sobre un array de índices basado en la longitud de x_data (que es 10)
            const dataPoints = Array.from({ length: realDataLength }).map((_, index) => ({
                x: regressionData.x_data[index],
                y: regressionData.y_data[index],
                value: regressionData.y_data_class[index] // Valor real (para colorear)
            }));
            
            // Obtenemos los valores de regresión para el mapa de color
            const allZ = regressionData.z_line;
            const minZ = Math.min(...allZ);
            const maxZ = Math.max(...allZ);
            const rangeZ = maxZ - minZ;
            
            // Función para obtener un color basado en el valor Z (simulando un colorbar)
            function getColorForValue(value) {
                if (rangeZ === 0) return COLOR_MAP_REGRESSION[0];
                const normalized = (value - minZ) / rangeZ;
                const colorIndex = Math.floor(normalized * (COLOR_MAP_REGRESSION.length - 1));
                return COLOR_MAP_REGRESSION[colorIndex];
            }
            
            // Aplicar colores a los puntos de la superficie
            const surfaceDatasets = [{
                type: 'scatter',
                label: `Superficie de Predicción`,
                data: surfacePoints,
                backgroundColor: surfacePoints.map(p => getColorForValue(p.z) + '40'), // 25% de opacidad
                pointRadius: 3, 
                pointStyle: 'rect',
                showLine: false,
                borderWidth: 0,
            }];
            
            // Puntos de Datos Reales
            const dataDatasets = [{
                type: 'scatter',
                label: `Datos Reales`,
                data: dataPoints,
                backgroundColor: dataPoints.map(p => getColorForValue(p.value)),
                pointRadius: 6,
                pointStyle: 'circle',
                borderColor: 'black',
                borderWidth: 1.5,
            }];
            
            // Título de la Gráfica
            document.getElementById('graph-title').textContent = `3. Gráfica de Superficie de Predicción (${regressionData.x_feature} vs ${regressionData.y_feature})`;
            
            if (window.regressionSurfaceChart && typeof window.regressionSurfaceChart.destroy === 'function') {
                window.regressionSurfaceChart.destroy();
            }

            // Calcular límites de ejes
            const allX = regressionData.x_data.concat(regressionData.x_line);
            const allY = regressionData.y_data.concat(regressionData.y_line);
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);
            
            // Añadir un margen (10% del rango)
            const xRange = maxX - minX;
            const yRange = maxY - minY;
            const xMargin = xRange * 0.1;
            const yMargin = yRange * 0.1;

            window.regressionSurfaceChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [...surfaceDatasets, ...dataDatasets] // Ambos datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            min: minX - xMargin,
                            max: maxX + xMargin,
                            title: {
                                display: true,
                                text: regressionData.x_feature
                            },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        },
                        y: {
                            min: minY - yMargin,
                            max: maxY + yMargin,
                            title: {
                                display: true,
                                text: regressionData.y_feature
                            },
                            grid: { color: 'rgba(0, 0, 0, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'circle'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const x = context.raw.x.toFixed(2);
                                    const y = context.raw.y.toFixed(2);
                                    
                                    let value;
                                    if (context.datasetIndex === 0) {
                                        // Superficie de predicción (valor Z)
                                        value = context.raw.z; 
                                        return `Superficie (Predicción): ${value.toExponential(2)}`;
                                    } else {
                                        // Punto real (valor 'value')
                                        value = context.raw.value;
                                        return `Punto Real (Valor): ${value.toExponential(2)} (${x}, ${y})`;
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }


        /**
         * Renderiza el DataFrame en una tabla HTML. (Tu función original)
         * @param {Array<Object>} dfData - Array de objetos (filas) desde el API.
         */
        function renderDataFrame(dfData) {
            const table = document.getElementById('dataframe-table');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');

            // Limpiar tabla
            thead.innerHTML = '';
            tbody.innerHTML = '';

            if (dfData && dfData.length > 0) {
                // Obtener encabezados del primer objeto
                const columns = Object.keys(dfData[0]);

                // Crear encabezados (thead)
                const headerRow = document.createElement('tr');
                columns.forEach(col => {
                    const th = document.createElement('th');
                    th.className = 'px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider';
                    th.textContent = col;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                // Crear filas de datos (tbody)
                dfData.forEach(rowData => {
                    const tr = document.createElement('tr');
                    tr.className = 'hover:bg-gray-50';
                    columns.forEach(col => {
                        const td = document.createElement('td');
                        td.className = 'px-4 py-3 whitespace-nowrap text-sm text-gray-900';
                        // Formatear números para legibilidad
                        const value = rowData[col];
                        if (typeof value === 'number') {
                            // Usar notación exponencial si el número es muy grande o pequeño para ahorrar espacio
                            td.textContent = value.toExponential(3); 
                        } else {
                            td.textContent = value;
                        }
                        tr.appendChild(td);
                    });
                    tbody.appendChild(tr);
                });
            } else {
                tbody.innerHTML = '<tr><td colspan="100%" class="px-6 py-4 text-center text-gray-500">No se encontraron datos del DataFrame.</td></tr>';
            }
        }

        // Iniciar la carga de datos al cargar la página
        window.onload = loadAndRenderData;
    </script>
</body>
</html>